const SYNC_BLOCKING_APIS = new Set([
    "localStorage",
    "sessionStorage",
    "document.cookie",
    "alert",
    "confirm",
    "prompt",
    "execSync",
    "readFileSync",
    "writeFileSync",
    "mkdirSync",
    "rmSync",
    "statSync",
    "JSON.parse", // when used with large data
    "JSON.stringify", // when used with large data
]);
const ASYNC_ALTERNATIVES = new Map([
    ["localStorage", "Use async storage or cache the value"],
    ["sessionStorage", "Use async storage or cache the value"],
    ["document.cookie", "Use async cookie libraries or cache cookies"],
    ["alert", "Use toast notifications or modal dialogs"],
    ["confirm", "Use async modal confirmations"],
    ["prompt", "Use form inputs or async modal prompts"],
    ["execSync", "Use exec() with callbacks or promises"],
    ["readFileSync", "Use fs.readFile() or fs.promises.readFile()"],
    ["writeFileSync", "Use fs.writeFile() or fs.promises.writeFile()"],
    ["JSON.parse", "Consider streaming JSON parsers for large data"],
    ["JSON.stringify", "Consider streaming JSON serializers for large data"],
]);
const rule = {
    meta: {
        type: "suggestion",
        docs: {
            description: "Disallow synchronous/blocking APIs that can cause main thread blocking and poor user experience",
        },
        schema: [],
        fixable: "code",
    },
    create(context) {
        function checkSyncAPI(node, apiName) {
            const suggestion = ASYNC_ALTERNATIVES.get(apiName) || "Consider using async alternatives";
            context.report({
                node,
                message: `Avoid synchronous '${apiName}' which blocks the main thread. ${suggestion}`,
            });
        }
        return {
            MemberExpression(node) {
                if (!node)
                    return;
                const obj = node.object;
                const prop = node.property;
                // Handle window.localStorage, document.cookie, etc.
                if (obj?.name === "window" && prop?.name) {
                    if (SYNC_BLOCKING_APIS.has(prop.name)) {
                        checkSyncAPI(node, prop.name);
                    }
                }
                else if (obj?.name === "document" && prop?.name === "cookie") {
                    checkSyncAPI(node, "document.cookie");
                }
                else if (obj?.name && SYNC_BLOCKING_APIS.has(obj.name)) {
                    checkSyncAPI(node, obj.name);
                }
                // Handle JSON.parse/stringify
                if (obj?.name === "JSON" && prop?.name && SYNC_BLOCKING_APIS.has(`JSON.${prop.name}`)) {
                    checkSyncAPI(node, `JSON.${prop.name}`);
                }
            },
            CallExpression(node) {
                if (!node)
                    return;
                // Handle direct calls like localStorage.getItem(), alert(), etc.
                if (node.callee?.type === "Identifier" && SYNC_BLOCKING_APIS.has(node.callee.name)) {
                    checkSyncAPI(node, node.callee.name);
                }
                else if (node.callee?.type === "MemberExpression") {
                    const obj = node.callee.object;
                    const prop = node.callee.property;
                    if (obj?.name === "JSON" && prop?.name && SYNC_BLOCKING_APIS.has(`JSON.${prop.name}`)) {
                        checkSyncAPI(node, `JSON.${prop.name}`);
                    }
                }
            },
        };
    },
};
export default rule;
